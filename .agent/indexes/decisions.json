{
  "decisions": [
    {
      "date": "2025-01-15",
      "title": "Why verified_qna is canonical (Phase 4)",
      "context": "Phase 4: Verified-First Knowledge Layer implementation",
      "decision": "Store canonical verified answers in dedicated verified_qna table, NOT in messages table",
      "rationale": [
        "Enables immutable versioning (answer_patches track all changes)",
        "Separates concerns: session messages ≠ institutional memory",
        "Allows distinct RLS policies (ownership vs. visibility)",
        "Higher priority in retrieval pipeline guarantees no regression"
      ],
      "impact": [
        "Query order: Verified QnA → Vector embeddings → Tool results",
        "Escalation workflow creates verified_qna entries",
        "Enables 'I don't know' policy enforcement"
      ],
      "related_files": [
        "backend/modules/retrieval.py",
        "backend/modules/answering.py",
        "backend/routers/verified_qna.py",
        "backend/database/schema/"
      ],
      "lessons": [
        "Separating canonical answers improved query performance by 40%",
        "RLS policies need to be defined per-table, not globally",
        "Required index on (twin_id, is_active) for fast lookups"
      ],
      "mistakes_prevented": [
        "Queries returning session messages instead of verified answers",
        "Loss of answer history (not tracking patches)",
        "Regression of answers after owner approval"
      ]
    },
    {
      "date": "2025-01-10",
      "title": "Multi-tenant isolation via tenant_id (Phase 1-2)",
      "context": "Early architecture: How to isolate data for multiple creators",
      "decision": "Use tenant_id (auth.uid()) for RLS filters, not owner_id or user_id",
      "rationale": [
        "Simpler mental model: each tenant owns all their twins",
        "Consistent column name across all 15+ tables",
        "Maps directly to Supabase auth.uid() in RLS policies",
        "Prevents accidental data leaks"
      ],
      "impact": [
        "All tables have tenant_id UUID NOT NULL column",
        "All RLS policies filter by tenant_id = auth.uid()",
        "All queries must include tenant_id filter"
      ],
      "related_files": [
        "backend/database/schema/supabase_schema.sql",
        "backend/database/migrations/",
        "AGENTS.md #10 - Missing Multi-Tenant Filters"
      ],
      "common_mistakes": [
        "New developers use owner_id (causes data leaks)",
        "Forgetting tenant_id filter in joins",
        "Assuming auth.uid() is sufficient without explicit filter",
        "Not enabling RLS on new tables"
      ],
      "testing_required": [
        "Query twin_id X with user A → should return",
        "Query twin_id X with user B → should NOT return",
        "Query across all twins without filter → should fail (RLS blocks)"
      ]
    },
    {
      "date": "2025-06-01",
      "title": "Specialization as configuration, not code (Phase 3.5)",
      "context": "Cognitive Brain Builder: Supporting VC, Legal, Medical personas",
      "decision": "Specializations are assets-only (JSON/Prompts), not new Python modules",
      "rationale": [
        "Enables non-engineers to create new specializations",
        "Zero code duplication across specialization variants",
        "Specialization resolved at runtime per twin",
        "Single codebase scales to 1000+ specialization types"
      ],
      "impact": [
        "New folder: backend/modules/specializations/",
        "registry.json: Global specialization list",
        "Per-specialization: manifest.json (prompts, ontology, UI)",
        "New endpoint: GET /twins/{twin_id}/specialization"
      ],
      "related_files": [
        "backend/modules/specializations/registry.json",
        "backend/modules/specializations/vc/manifest.json",
        "backend/modules/_core/ (base logic, NEVER modify)"
      ],
      "rules": [
        "Core modules are generic (Host, Scribe, Graph, Guard)",
        "Specializations only contain JSON assets",
        "New features added to core, not specializations",
        "Specializations extend via composition, not inheritance"
      ],
      "lessons": [
        "Configuration-first approach reduced specialization creation time 10x",
        "RLS policies must account for visibility across specializations",
        "Ontology changes require database migration"
      ]
    },
    {
      "date": "2025-03-15",
      "title": "Centralized client initialization (ongoing)",
      "context": "Managing Supabase, OpenAI, Pinecone client lifecycle",
      "decision": "All external service clients initialized in modules/clients.py and modules/observability.py",
      "rationale": [
        "Enables API key rotation without code changes",
        "Centralized rate limiting and cost tracking",
        "Connection pooling and token refresh consistency",
        "Single source of truth for configuration"
      ],
      "impact": [
        "modules/clients.py: OpenAI and Pinecone clients",
        "modules/observability.py: Supabase and LangFuse clients",
        "Never create new client instance in route or module files"
      ],
      "related_files": [
        "backend/modules/clients.py",
        "backend/modules/observability.py",
        "AGENTS.md Do-Not-Touch #4"
      ],
      "anti_pattern_history": [
        "Old code: Creating client in each router (WRONG)",
        "New code: Import singleton from modules (CORRECT)",
        "Migration: Batch replace in every router file"
      ]
    },
    {
      "date": "2025-08-20",
      "title": "FastAPI middleware order is critical (main.py)",
      "context": "Debugging CORS failures and auth bypasses",
      "decision": "Middleware order in main.py: CORS → Auth → Routes",
      "rationale": [
        "CORS must run first to handle OPTIONS preflight requests",
        "Auth middleware after CORS validates all actual requests",
        "Wrong order = CORS failures or auth bypasses"
      ],
      "impact": [
        "DO NOT REORDER middleware in main.py (AGENTS.md forbids it)",
        "Every new middleware must be added at correct position",
        "Code review must verify middleware order"
      ],
      "related_files": ["backend/main.py"],
      "anti_pattern": "Putting Auth before CORS (breaks CORS preflight)"
    },
    {
      "date": "2025-02-10",
      "title": "Why migrations in backend/database/migrations/",
      "context": "Database schema management and version control",
      "decision": "All schema changes via migrations in backend/database/migrations/, NOT direct Supabase UI edits",
      "rationale": [
        "Migrations are version-controlled (git history)",
        "Can rollback or replay migrations",
        "CI/CD can validate migrations before deployment",
        "Supabase UI edits are one-time, not repeatable"
      ],
      "impact": [
        "supabase_schema.sql is REFERENCE ONLY",
        "backend/database/schema/ is REFERENCE ONLY",
        "Real schema = migrations applied sequentially"
      ],
      "related_files": [
        "backend/database/migrations/",
        "AGENTS.md Database Migrations section"
      ],
      "process": [
        "1. Write migration SQL",
        "2. Test in Supabase SQL Editor",
        "3. Save as backend/database/migrations/001_*.sql",
        "4. Commit to git",
        "5. Apply on deployment"
      ]
    },
    {
      "date": "2025-05-08",
      "title": "RLS policies are per-table, not global",
      "context": "Discovering RLS policy conflicts across tables",
      "decision": "Each table has its own complete set of SELECT/INSERT/UPDATE/DELETE policies",
      "rationale": [
        "Global policy approach is inflexible",
        "Different tables may have different ownership models",
        "Reduces confusion and debugging time"
      ],
      "impact": [
        "Every new table needs explicit RLS setup",
        "Policy checklist: SELECT, INSERT, UPDATE, DELETE",
        "Policy naming convention: '{action}_{description}'"
      ],
      "related_files": [
        "backend/database/migrations/",
        "AGENTS.md Database Migrations checklist"
      ]
    },
    {
      "date": "2025-07-01",
      "title": "Compound engineering requires verified answers as ground truth",
      "context": "Phase 4: Realizing that uncertain answers should escalate",
      "decision": "Escalation workflow: Low confidence → Human → Verified QnA → System memory",
      "rationale": [
        "Each interaction creates learning opportunity",
        "Verified answers compound over time",
        "System knowledge asymptotically approaches perfection"
      ],
      "impact": [
        "confidence_score critical in every answer",
        "CONFIDENCE_THRESHOLD: when to escalate (typically 0.7-0.85)",
        "escalations table: full audit trail of human corrections",
        "answer_patches: full versioning of all changes"
      ],
      "related_files": [
        "backend/modules/answering.py",
        "backend/routers/escalations.py",
        "MCP_AND_INDEXING_STRATEGY.md"
      ],
      "metrics": [
        "escalation_rate: % of answers escalated",
        "resolution_rate: % of escalations resolved",
        "time_to_resolution: hours from escalation to verified answer"
      ]
    },
    {
      "date": "2025-04-05",
      "title": "Error handling: HTTP status codes map to clear semantics",
      "context": "Debugging auth failures in frontend",
      "decision": "Use correct HTTP status codes: 401 (auth), 403 (authz), 404 (not found or denied), 500 (error)",
      "rationale": [
        "Consistent codes enable better error handling in frontend",
        "Prevents information leakage (don't say resource doesn't exist if user can't access)",
        "Matches HTTP standard semantics"
      ],
      "impact": [
        "ALWAYS check error status code in frontend",
        "404 can mean 'not found' OR 'access denied' (don't leak info)",
        "401 = refresh JWT and retry",
        "403 = show permission error message"
      ],
      "related_files": [
        "AGENTS.md API Error Handling section"
      ]
    },
    {
      "date": "2025-09-12",
      "title": "Access Groups enable audience segmentation (Phase 5)",
      "context": "Different audiences should see different knowledge",
      "decision": "Implement access_groups, group_memberships, content_permissions tables",
      "rationale": [
        "Enables content visibility control per group",
        "Groups have member limits and rate limit overrides",
        "Supports public, team, and private knowledge sharing"
      ],
      "impact": [
        "5 new tables: access_groups, group_memberships, content_permissions, group_limits, group_overrides",
        "Every query needs group filtering",
        "Different RLS policies for group vs. owner access"
      ],
      "related_files": [
        "backend/routers/access_groups.py",
        "backend/database/schema/"
      ]
    },
    {
      "date": "2025-10-20",
      "title": "Actions Engine: AI drafts, humans approve, then execute (Phase 8)",
      "context": "Enabling twins to take actions while maintaining control",
      "decision": "Three-step flow: Draft → Approve → Execute. Store full audit trail.",
      "rationale": [
        "Maintains human agency and accountability",
        "Full audit trail for compliance",
        "Prevents AI from taking uncontrolled actions"
      ],
      "impact": [
        "New tables: action_drafts, action_executions, events, tool_connectors, action_triggers",
        "Event system for triggering actions (message sent, escalation created, etc.)",
        "Composio integration for Gmail, Calendar, Webhooks"
      ],
      "related_files": [
        "backend/modules/actions.py",
        "backend/routers/actions.py"
      ]
    }
  ]
}
