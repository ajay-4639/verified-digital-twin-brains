{
  "metadata": {
    "version": "1.0",
    "created_at": "2025-01-20",
    "description": "Compound Engineering Knowledge Graph - Interconnected patterns and concepts"
  },
  "nodes": [
    {
      "id": "concept_multi_tenancy",
      "type": "concept",
      "title": "Multi-Tenant Isolation",
      "definition": "Architectural pattern where a single system serves multiple independent users (tenants), with guaranteed data isolation",
      "importance": "CRITICAL",
      "related_concepts": ["rls", "security", "data_privacy"],
      "implementation_patterns": ["multi_tenant_filter", "auth_check_standard"],
      "failure_cases": ["AGENTS.md #10 - Missing Multi-Tenant Filters"],
      "best_practices": [
        "Always filter by tenant_id (auth.uid()) in RLS policies",
        "Never query without tenant_id filter",
        "Enable RLS on every new table",
        "Test with multiple users to verify isolation"
      ],
      "related_files": [
        "backend/database/schema/supabase_schema.sql",
        "AGENTS.md"
      ]
    },
    {
      "id": "concept_rls",
      "type": "concept",
      "title": "Row Level Security (RLS)",
      "definition": "PostgreSQL feature that filters rows at query time based on auth context",
      "importance": "CRITICAL",
      "technical_detail": "Queries include WHERE clause with auth.uid() context automatically",
      "related_concepts": ["multi_tenancy", "security"],
      "implementation_patterns": ["rls_policy_creation", "multi_tenant_filter"],
      "failure_cases": [
        "Enabling RLS without policies (locks out all access)",
        "Using wrong column in policy (e.g., user_id instead of tenant_id)",
        "Forgetting RLS on sensitive tables"
      ],
      "best_practices": [
        "Always test policies in Supabase SQL Editor first",
        "Include SELECT, INSERT, UPDATE, DELETE policies",
        "Use tenant_id = auth.uid() as base filter"
      ]
    },
    {
      "id": "concept_compound_engineering",
      "type": "concept",
      "title": "Compound Engineering",
      "definition": "System where every interaction with the AI generates knowledge that improves future interactions",
      "importance": "FOUNDATIONAL",
      "core_loop": [
        "User asks question",
        "AI generates answer with confidence score",
        "Low confidence â†’ Escalate to human",
        "Human provides verified answer",
        "Verified answer becomes system memory (verified_qna)",
        "Next similar question uses verified answer (higher confidence)"
      ],
      "key_tables": [
        "verified_qna (canonical answers)",
        "escalations (human interventions)",
        "answer_patches (answer versioning)",
        "messages (conversation history)"
      ],
      "related_concepts": ["knowledge_base", "verification", "escalation"],
      "implementation_patterns": [
        "verified_qna_retrieval_priority",
        "escalation_workflow",
        "confidence_scoring"
      ],
      "metrics": [
        "escalation_rate",
        "resolution_rate",
        "verified_qna_coverage",
        "confidence_distribution"
      ]
    },
    {
      "id": "concept_verified_knowledge",
      "type": "concept",
      "title": "Verified Knowledge",
      "definition": "Canonical, human-approved answers that are the source of truth for the system",
      "importance": "HIGH",
      "characteristics": [
        "Immutable once created (changes via answer_patches)",
        "Highest priority in retrieval (returned before vector search)",
        "Never regresses after approval",
        "Auditable: full history of changes"
      ],
      "related_concepts": ["compound_engineering", "escalation", "trust"],
      "implementation_patterns": [
        "verified_qna_retrieval_priority",
        "database_migration_template"
      ],
      "related_files": [
        "backend/modules/verified_qna.py",
        "backend/routers/verified_qna.py"
      ]
    },
    {
      "id": "concept_escalation",
      "type": "concept",
      "title": "Escalation Workflow",
      "definition": "Process of raising uncertain AI answers to human experts for verification",
      "importance": "HIGH",
      "flow": [
        "AI generates answer with confidence_score",
        "If confidence < CONFIDENCE_THRESHOLD (typically 0.7-0.85)",
        "Create escalation record",
        "Notify human expert",
        "Human verifies or provides correct answer",
        "Create verified_qna entry",
        "Close escalation"
      ],
      "related_concepts": ["compound_engineering", "verified_knowledge", "human_in_loop"],
      "implementation_patterns": ["escalation_workflow"],
      "key_decision": "CONFIDENCE_THRESHOLD value determines escalation frequency",
      "metrics": [
        "escalation_rate (% of answers escalated)",
        "resolution_rate (% of escalations resolved)",
        "time_to_resolution (hours)"
      ]
    },
    {
      "id": "pattern_auth_check_standard",
      "type": "implementation_pattern",
      "title": "Standard Auth Check Pattern",
      "location": "backend/routers/*.py",
      "implements_concepts": ["multi_tenancy", "security"],
      "reusable": true,
      "usage_count": 24,
      "code_template": "@router.get('/resource/{id}')\\nasync def get_resource(\\n    id: str,\\n    user: dict = Depends(get_current_user)\\n):\\n    verify_owner(user, id)\\n    # ... rest",
      "required_imports": [
        "from modules.auth_guard import get_current_user, verify_owner"
      ],
      "variation": [
        {
          "name": "Basic auth check",
          "use_case": "Most endpoints"
        },
        {
          "name": "Group membership check",
          "use_case": "Access group endpoints",
          "modification": "Use verify_group_member instead of verify_owner"
        }
      ],
      "anti_patterns": [
        "Manual JWT parsing",
        "Hardcoded admin checks",
        "Missing verify_owner call"
      ]
    },
    {
      "id": "pattern_multi_tenant_filter",
      "type": "implementation_pattern",
      "title": "Multi-Tenant Query Filter",
      "location": "backend/routers/*.py, backend/modules/*.py",
      "implements_concepts": ["multi_tenancy", "rls"],
      "reusable": true,
      "usage_count": 31,
      "code_template": "supabase.table('table').select('*').eq('tenant_id', user['tenant_id']).execute()",
      "required_column": "tenant_id UUID NOT NULL (in every table)",
      "correct_value": "user['tenant_id'] (= auth.uid())",
      "wrong_values": ["user['id']", "owner_id", "user_id"],
      "checklist": [
        "[ ] Is tenant_id included in SELECT?",
        "[ ] Does .eq() filter by tenant_id?",
        "[ ] Is the value user['tenant_id']?",
        "[ ] What about JOIN queries? (Must filter all tables)"
      ]
    },
    {
      "id": "pattern_verified_qna_priority",
      "type": "implementation_pattern",
      "title": "Verified QnA Retrieval Priority",
      "location": "backend/modules/retrieval.py",
      "implements_concepts": ["verified_knowledge", "compound_engineering"],
      "reusable": true,
      "usage_count": 3,
      "query_order": [
        {
          "step": 1,
          "source": "verified_qna",
          "priority": "Highest",
          "reason": "Canonical answers, human-verified, never regress"
        },
        {
          "step": 2,
          "source": "vector_embeddings",
          "priority": "High",
          "reason": "Semantic search of documents"
        },
        {
          "step": 3,
          "source": "tool_results",
          "priority": "Medium",
          "reason": "External service results (last resort)"
        }
      ],
      "why_order_critical": "Ensures verified answers always used, preventing regression",
      "common_mistakes": [
        "Searching vectors before verified_qna",
        "Not checking is_active flag",
        "Missing twin_id filter"
      ]
    },
    {
      "id": "pattern_rls_policy_creation",
      "type": "implementation_pattern",
      "title": "RLS Policy Creation Template",
      "location": "backend/database/migrations/*.sql",
      "implements_concepts": ["rls", "multi_tenancy"],
      "reusable": true,
      "usage_count": 15,
      "template_file": "See database_migration_template pattern",
      "required_steps": [
        "1. ALTER TABLE ... ENABLE ROW LEVEL SECURITY",
        "2. CREATE POLICY for SELECT",
        "3. CREATE POLICY for INSERT",
        "4. CREATE POLICY for UPDATE",
        "5. CREATE POLICY for DELETE"
      ],
      "validation": [
        "Test in Supabase SQL Editor",
        "Verify with auth.uid() context",
        "Test as different users"
      ]
    },
    {
      "id": "pattern_dependency_injection",
      "type": "implementation_pattern",
      "title": "FastAPI Dependency Injection",
      "location": "backend/routers/*.py",
      "implements_concepts": ["security", "separation_of_concerns"],
      "reusable": true,
      "usage_count": 28,
      "benefits": [
        "Auth logic separated from route logic",
        "Dependencies run in dependency order",
        "Reusable across all routes",
        "Easy to test (mock dependencies)"
      ],
      "code_template": "user: dict = Depends(get_current_user)",
      "custom_dependencies": [
        "get_current_user (from auth_guard.py)",
        "load_resource (custom validators)",
        "check_permission (custom checks)"
      ]
    },
    {
      "id": "pattern_client_singleton",
      "type": "implementation_pattern",
      "title": "Client Singleton Pattern",
      "location": "backend/modules/clients.py, backend/modules/observability.py",
      "implements_concepts": ["client_management", "configuration"],
      "reusable": true,
      "usage_count": 45,
      "clients": [
        {
          "name": "supabase",
          "location": "modules.observability",
          "reason": "Centralized auth token management"
        },
        {
          "name": "openai",
          "location": "modules.clients",
          "reason": "Centralized API key rotation"
        },
        {
          "name": "pinecone",
          "location": "modules.clients",
          "reason": "Connection pooling"
        }
      ],
      "anti_pattern": "Creating new client instance in each module",
      "benefits": [
        "Token refresh consistency",
        "Connection pooling",
        "Rate limiting at single point",
        "Cost tracking",
        "API key rotation without code changes"
      ]
    },
    {
      "id": "pattern_database_migration",
      "type": "implementation_pattern",
      "title": "Database Migration Template",
      "location": "backend/database/migrations/*.sql",
      "implements_concepts": ["database_versioning", "rls"],
      "reusable": true,
      "usage_count": 7,
      "required_sections": [
        "Comment header (purpose, date, author)",
        "CREATE TABLE IF NOT EXISTS",
        "ALTER TABLE ... ENABLE RLS",
        "CREATE POLICY statements",
        "CREATE INDEX statements"
      ],
      "testing": "Always test in Supabase SQL Editor first",
      "validation_checklist": [
        "[ ] Uses IF NOT EXISTS (idempotent)",
        "[ ] Includes REFERENCES with ON DELETE",
        "[ ] Enables RLS",
        "[ ] Has SELECT policy",
        "[ ] Has INSERT policy",
        "[ ] Has UPDATE policy",
        "[ ] Has DELETE policy",
        "[ ] Indexes on FK columns",
        "[ ] Tested in Supabase SQL Editor"
      ]
    },
    {
      "id": "pattern_escalation_workflow",
      "type": "implementation_pattern",
      "title": "Escalation Workflow Pattern",
      "location": "backend/modules/answering.py",
      "implements_concepts": ["compound_engineering", "escalation"],
      "reusable": true,
      "usage_count": 8,
      "flow_steps": [
        "Calculate confidence_score",
        "If confidence < CONFIDENCE_THRESHOLD",
        "Create escalation record",
        "Return 'escalated' status",
        "Notify human"
      ],
      "key_parameters": [
        {
          "name": "CONFIDENCE_THRESHOLD",
          "typical_value": 0.7,
          "range": "0.6-0.85",
          "tuning": "Higher = more escalations, more verified answers"
        }
      ]
    },
    {
      "id": "pattern_error_handling",
      "type": "implementation_pattern",
      "title": "HTTP Error Handling Pattern",
      "location": "backend/routers/*.py",
      "implements_concepts": ["security", "api_design"],
      "reusable": true,
      "usage_count": 19,
      "status_codes": [
        {
          "code": 401,
          "meaning": "Unauthorized (missing/invalid JWT)",
          "example": "Missing authentication token"
        },
        {
          "code": 403,
          "meaning": "Forbidden (access denied by authorization)",
          "example": "Access denied: not resource owner"
        },
        {
          "code": 404,
          "meaning": "Not Found OR Access Denied",
          "example": "Twin not found or access denied",
          "note": "Don't leak resource existence"
        },
        {
          "code": 500,
          "meaning": "Server Error (unexpected exception)",
          "example": "Internal server error"
        }
      ],
      "anti_patterns": [
        "Returning 404 for auth failures (confusing)",
        "Returning 500 for permission errors (wrong HTTP semantics)",
        "Revealing why resource wasn't found"
      ]
    },
    {
      "id": "pattern_pydantic_validation",
      "type": "implementation_pattern",
      "title": "Pydantic Response Validation",
      "location": "backend/modules/schemas.py",
      "implements_concepts": ["validation", "type_safety"],
      "reusable": true,
      "usage_count": 22,
      "benefits": [
        "Automatic type checking",
        "Validation error messages",
        "OpenAPI documentation generation",
        "IDE auto-complete"
      ],
      "pattern": "Use BaseModel for all request/response types",
      "example_fields": [
        "Field(..., description='...')",
        "Field(default=..., ge=0.0, le=1.0)",
        "Optional[type] for nullable fields"
      ]
    },
    {
      "id": "concept_specialization",
      "type": "concept",
      "title": "Specialization Architecture",
      "definition": "Configuration-first system for creating domain-specific twin variants (VC, Legal, Medical)",
      "importance": "MEDIUM",
      "key_principle": "Specializations are assets (JSON/Prompts), NOT code",
      "structure": [
        "registry.json: Global specialization list",
        "Per-specialization: manifest.json (prompts, ontology, UI)",
        "No Python code changes needed for new specialization"
      ],
      "related_concepts": ["configuration_driven", "scalability"],
      "implementation_patterns": ["specialization_manifest_resolution"],
      "benefits": [
        "Non-engineers can create specializations",
        "Scales to 1000+ specialization types",
        "Zero code duplication"
      ]
    },
    {
      "id": "concept_observability",
      "type": "concept",
      "title": "Observability & Logging",
      "definition": "Complete audit trail of agent behavior for debugging and understanding",
      "importance": "HIGH",
      "tools": [
        "LangFuse: Session tracking, message logging, cost tracking",
        "Supabase logs: Database queries, RLS policies",
        "Backend logs: Application errors, warnings"
      ],
      "related_concepts": ["debugging", "learning"],
      "implementation_patterns": ["langfuse_session_tracking"],
      "benefits": [
        "Full conversation audit trail",
        "Performance monitoring per user/twin",
        "Cost tracking per operation",
        "User behavior analytics"
      ]
    },
    {
      "id": "concept_access_groups",
      "type": "concept",
      "title": "Access Groups & Segmentation",
      "definition": "System for controlling content visibility across different audiences",
      "importance": "MEDIUM",
      "use_cases": [
        "Public knowledge (everyone sees)",
        "Team knowledge (team members only)",
        "Private knowledge (owner only)"
      ],
      "related_tables": [
        "access_groups",
        "group_memberships",
        "content_permissions",
        "group_limits",
        "group_overrides"
      ],
      "implementation_patterns": ["access_group_filtering"]
    }
  ],
  "edges": [
    {
      "source": "concept_multi_tenancy",
      "target": "concept_rls",
      "relation": "implemented_by",
      "strength": 0.95,
      "description": "Multi-tenancy achieved through RLS policies"
    },
    {
      "source": "concept_multi_tenancy",
      "target": "pattern_multi_tenant_filter",
      "relation": "implemented_by",
      "strength": 0.9,
      "description": "Every query implements multi-tenant filter"
    },
    {
      "source": "concept_rls",
      "target": "pattern_rls_policy_creation",
      "relation": "implemented_by",
      "strength": 0.95,
      "description": "RLS implemented via policy creation pattern"
    },
    {
      "source": "concept_compound_engineering",
      "target": "concept_verified_knowledge",
      "relation": "requires",
      "strength": 0.95,
      "description": "Compounding depends on canonical verified answers"
    },
    {
      "source": "concept_compound_engineering",
      "target": "concept_escalation",
      "relation": "requires",
      "strength": 0.95,
      "description": "Compounding loop driven by escalation to humans"
    },
    {
      "source": "concept_escalation",
      "target": "pattern_escalation_workflow",
      "relation": "implemented_by",
      "strength": 0.9,
      "description": "Escalation implemented via workflow pattern"
    },
    {
      "source": "concept_verified_knowledge",
      "target": "pattern_verified_qna_priority",
      "relation": "implemented_by",
      "strength": 0.95,
      "description": "Verified knowledge prioritized in retrieval"
    },
    {
      "source": "pattern_auth_check_standard",
      "target": "pattern_dependency_injection",
      "relation": "uses",
      "strength": 0.85,
      "description": "Auth checks use FastAPI dependency injection"
    },
    {
      "source": "pattern_multi_tenant_filter",
      "target": "pattern_database_migration",
      "relation": "requires",
      "strength": 0.8,
      "description": "Tenant filters require tenant_id column in migrations"
    },
    {
      "source": "pattern_client_singleton",
      "target": "concept_observability",
      "relation": "enables",
      "strength": 0.8,
      "description": "Centralized clients enable observability"
    },
    {
      "source": "concept_specialization",
      "target": "pattern_specialization_manifest_resolution",
      "relation": "implemented_by",
      "strength": 0.9,
      "description": "Specializations resolved at runtime"
    },
    {
      "source": "concept_access_groups",
      "target": "pattern_access_group_filtering",
      "relation": "implemented_by",
      "strength": 0.9,
      "description": "Access groups implemented via filtering pattern"
    },
    {
      "source": "pattern_error_handling",
      "target": "pattern_auth_check_standard",
      "relation": "used_by",
      "strength": 0.85,
      "description": "Auth checks use error handling patterns"
    },
    {
      "source": "pattern_pydantic_validation",
      "target": "pattern_error_handling",
      "relation": "enables",
      "strength": 0.8,
      "description": "Pydantic validation enables clear error messages"
    }
  ]
}
